package Interface.Set;
/*
 * Hash는 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환(매핑)하는 것이다.
 * 그리고 위와 같은 기능을 하는 함수를 해시 함수(Hash Function)이라고 한다.
 * 
 * 예를 들어 "abcd" 라는 문자열이 있으면 이를 특정 길이의 데이터로 변환시키는 것이다.
 * "a" => 86aff3ca (16진수)
 * 
 * 즉, 해시 함수를 돌리기 전 문자열의 길이가 얼마건 일정한 길이를 얻는다는 것이다.
 * 
 * 복잡하게 해시 함수를 돌리는 이유는 데이터를 찾기위해 순회할 필요가 없다는 것이다.
 * 리스트 계열 컬렉션 등, 수 많은 자료구조에서 특정 값을 찾아내기 위해 노드를 순회하며 찾았다.
 * 
 * 하지만 해시 함수를 이용한다면 굳이 순회할 필요가 없다.
 * 동일한 값에 대해서는 동일한 다이제스트를 갖기 때문이다.
 * 문자열 "a"를 동일한 해시 알고리즘을 사용하여 돌리면 동일한 86aff3ca 값을 얻는다는 것이다.
 * 
 * 즉, 특정한 값에 대한 다이제스트는 변하지 않기 때문에 이 다이제스트의 값을 배열의 위치로 활용하는 것이다.
 * 
 * 또한 Set은 중복을 허용ㅎ지 않는다.
 * 이 말은 우리가 원소를 추가할 때마다 해당 원소가 중복되는 원소인지 아닌지 검사해야하는데,
 * 그럴때마다 순회를 하면 비효율적이다.
 * 
 * 그렇기에 고안한 방법이 hash 함수를 통해 특정 값에 대한 고유의 다이제스트를 얻고, 그 값에 대응하는 index를 찾아서
 * 해당 인덱스에 있는 요소만 검사하면 되는 것이다.
 * 
 * 이것이 HashSet으 기본 개념이다.
 * 
 * 자바에서는 hashCode()라는 매우 간편한 함수가 있어 따로 Hash 함수를 구현할 필요가 없다.
 * 
 * HashCode()는 객체의 "주소값"을 이용하여 해시 알고리즘에 의해 생성된 고유의 정수값을 반환한다.
 * 즉, 객체가 같은 "메모리 주소"를 가리키고 있다면 같은 정수값을 얻을 것이다. 
 * 더 풀어서 설명하자면, 객체가 같은 내용을 가지더라도, 주소가 다르면 다른 값을 지닌다!
 * new로 생성된 객체들은 전부 주소가 다르기 때문에, 다른 값이다.
 * 
 * 우리가 사용하는 String, int, double 등의 자료형들은 hashCode()를 오버라이드 하여
 * 객체의 "내용"이 비교될 수 있도록 재정의 하고 있다.
 * 
 * 그렇기 때문에 기본적으로 HashSet을 쓸 때 우리가 쓰는 기본 자료형으로는 같은 내용일 경우
 * 동일한 값을 갖는다.
 * 
 * 만약 사용자 클래스를 사용하게 될 경우, 해당 클래스 내에 hashCode 메서드를 오버라이드 해주지 않으면
 * 메모리 주소를 기반으로 해싱된 값이 나오기 때문에, 전부 다른 다이제스트를 가리키게 된다.
 * 객체 내용 비교를 위해서는 반드시 hashCode()를 오버라이드 해주어야 한다.
 * 
 * 
 * 위의 해시 함수, HashCode() 이외에도 추가로 반드시 알아야하는 개념이 있다.
 * 바로 해시 충돌이라는 것이다.
 * 
 * 위 hashCode()를 사용하더라도 1차적인 문제점이 있다. int형의 범위이다.
 * int는 32비트로 표현되는 자료형이다.
 * 즉, 2^32 경우의 수를 갖을 수 있다는 의미다.
 * 
 * 하지만 우리가 생성가능한 경우의 수는 훨씬 많을 것이다.
 * 그렇게 발생되는, 객체가 다른 내용을 가지고 있는데, 해싱된 값이 같은 경울를 해싱 충돌이라고 한다.
 * 
 * 또한 생성된 모든 객체가 2^32 만큼 표현 가능하더라도, 그 만큼의 버킷(배열) 공간을 생성해야한다는 점이다.
 * 이는 메모리 낭비가 심하고, Java에서는 단일 배열에 대해 약 21억 크기까지만 생성이 가능하다.
 * 
 * 그렇기 떄문에 메모리의 낭비를 줄이기 위해 배열의 사이즈를 줄여서 사용한다.
 * int index = X.hashCode() % M;
 * int index = Math.abs(X.hashCode()) % M; => 음수 값이 나올 수도 있어서 절대값으로 변환.
 * 
 * 위와 같이 해주어도 배열의 크기에 따른 index르 참조하는 일이 발생할 수 밖에 없다.
 * 그 경우는 Open Addressing과 Separate Chaining 방식 등을 사용하여 해소한다.
 * => 이 방식들은 따로 정리 할 예정
 * 
 * 자바에서는 Separate Chaining 방식을 채택하고 있다.
 * 
 */
public class HashSet {

}
