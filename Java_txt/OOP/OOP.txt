■ 객체 지향 언어를 사용하는 이유
1. 코드의 재사용성이 높다.
=> 기존의 코드를 이용하여 쉽게 작성 가능하다.

2. 코드의 관리가 용이하다.
=> 코드 간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경 가능하다.

3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
=> 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지.
=> 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지한다.


■ 클래스
- 정의 : 객체를 정의해 놓은 걸,, 객체의 설계도 또는 틀.
- 용도 : 클래스는 객체를 생성하는데 사용한다.


■ 객체
- 정의 : 실제로 존재하는 것(유/무형)
- 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

- 우리가 원하는 기능의 객체를 사용하기 위해서는 클래스로부터 객체를 생성하는 과정이 선행되어야 한다.

객체는 속성과 기능 두 종류의 구성요소로 이루어져 있다. 일반적으로 객체는 다수의 속성과 다수의 기능을 갖는다.
=> 객체 : 속성과 기능의 집합.
=> 속성과 기능 : 객체의 멤버라고 부른다.

-객체 지향 프로그래밍에서는 속성은 멤버변수, 기능은 메서드라고 한다.


■ 클래스의 인스턴스화
- 클래스로부터 객체를 만드는 과정
- 인스턴스는 갹채와 같은 의미지만, 객체는 모든 인스턴스를 대표하는 "포괄적인 의미"를 가지고 있다.
- 인스턴스는 어떤 클래스로부터 만들어진 것인지를 "강조"하는 의미를 가지고 있다.


-- 내가 스스로 정의해 본 것
책상은 객체이다(o), 책상은 인스턴스이다(△)
책상은 책상클래스의 객체이다(△), 책상은 책상클래스의 인스턴스이다(o)
--


■ 객체의 생성과 사용
- 클래스명 변수명; 
=> 클래스의 객체를 참조하기 위한 참조 변수 선언.

- 변수명 = new 클래스명(); 
=> 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장.

ex) A aa = new A();  
=> A클래스로부터 객체가 만들어짐.


■ 참조변수 인스턴스 생성 및 클래스 접근 원리
1. 연산자 new에 의해 A클래스의 인스턴스가 메모리 빈 공간에 형성.
2. 대입 연산자(=)에 의해 // 생성된 객체의 주소값이 참조 변수 aa에 저장.
3. 참조변수 aa를 통해 A인스턴스에 접근 가능

- 인스턴스는 참조변수를 통해서만 다룰수 있으며, 참조 변수의 타입은 인스턴스의 타입과 일치해야한다.
- 같은 클래스로부터 객체를 생성했을지라도, 참조변수가 참조하는 값이 달라, 서로 다른 값을 유지할 수 있다.


■ 객체 배열은 참조변수들을 하나로 묶은 참조변수이다.
- TV[] tvArr = new TV[3];
=> 길이가 3인 TV 타입의 참조변수 배열

- tvArr[n] 들의 주소값이 저장되지 않음
- tvArr[0] = new TV(); tvArr[1] = new TV(); tvArr[2] = new TV(); 각각 인스턴스를 생성하여 저장해주면 됨.


□ 소스 파일과 클래스 파일 
=> 추후 자세히 다룰 예정.

 
■ 객체지향 프로그래밍 구성요소
- 변수 : 하나의 데이터를 저장할 수 있는 공간.
- 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간.
- 구조체 : 서로 관련된 데이터를 종류에 관계 없이 하나의 집합으로 저장할 수 있는 공간.
- 클래스 : 데이터와 함수의 결합 (구조체 + 함수)

클래스 > 구조체, 함수
구조체 > 배열, 변수
배열 > 변수


■ 변수의 종류
- 인스턴스 변수 : 클래스 영역에 선언, 인스턴스를 생성할 때 만들어진다.
=> 인스턴스가 없으면 접근 불가.

- 클래스 변수 : 클래스 영역에 선언, 앞에 static을 붙인다. 모든 인스턴스는 클래스 변수를 공유한다.
=> 인스턴스 없어도 접근 가능.

- 지역 변수 : 메서드 영역에서 선언, 메서드 내에서만 사용 가능하고, 메서드가 종료되면 사라진다.

!! 궁금한 점 : 인스턴스로 클래스 변수의 값을 바꾸면 다른 인스턴스에서도 바뀐 값을 볼 수 있나?
=> 다른 인스턴스와 공유되어 적용된다. 즉 바뀐 값을 볼 수 있다.
=> 하지만, 인스턴스 클래스 변수는 코드를 볼 때 헷갈리기 쉬우니 클래스.클래스변수로 작성하자.


■ 메서드
- 메서드는 선언부와 구현부로 나눈다.
=> 선언부 : 메서드의 이름, 매개변수의 선언, 반환 타입
ex) int run (int speed, int weight)

=> 구현부 : 지역 변수, 리턴문
ex) {
 int cd = speed * weight;
 return time * 60;
}

- 메서드의 호출은 메서드의 이름(인수 or 인자)로 호출한다.
- 인수 or 인자는 메서드 선언부의 매개변수이며, 타입과 순서가 일치해야한다.
- 이 때 인수 or 인자는 자동형변환이 가능한 타입을 넣어도 된다.

- 메서드가 호출되면, 현재의 메서드 흐름을 중단하고, 호출된 메서드를 실행시킨 뒤, 호출된 메서드의 작업이 종료되면, 중단되었던 메서드를 이어서 실행한다.

- 메서드 선언부에 반환타입이 void가 아닐 경우, 구현부에서는 리턴문을 어떤 조건에서든지 무조건 한 개가 반환도도록 지정해야함.


■ 호출 스택
- 메서드 작업에 필요한 메모리 공간을 제공한다.
- 메서드가 호출되면, 호출 스택에 "호출된 메서드"를 위한 메모리가 할당된다.
=> 메모리 : 지역변수, 매개변수들과 연산의 중간 결과 등을 저장하는데 사용된다.
=> 메서드가 작업을 마치면 할당된 메모리 공간은 반환되어 비워진다.

1. 메서드가 호출되면, 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
2. 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
3. 호출 스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
4. 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

- 반환타입이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드에게 반환한다.
- 대기 상태에 있던 호출한 메서드는 넘겨 받은 반환 값으로 수행을 계속 진행하게 된다.


■ 매개변수
- 자바에서는 메서드를 호출할 때, 매개변수로 지정한 값을 인자를 통하여 메서드의 매개변수에 복사해서 넘겨준다.
- 매개변수 타입이 기본현 일때는 기본형의 값이 복사되겠지만, 참조형이면 인스턴스의 주소가 복사된다.
=> 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.(read only)
=> 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.(read & write)


■ static
1. 클래슬르 설계할 때 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.

2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
=> static이 붙은 변수는 클래스가 메모리에 올라갈 때 함께 자동적으로 생성되기 때문이다.

3. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.
=> 인스턴스 변수는 인스턴스가 생성되어야 사용가능한데, 클래스 메서드는 인스턴스 생성 없이 호출 가능하기 때문이다.
=> 클래스 메서드는 메모리에 존재하지만, 인스턴스 변수는 그 시점에 메모리에 존재하지 않는다.

4. 메서드 내에 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
=> 메서드의 작업 내용 중 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다.
=> static을 붙이는 이유는 메서드 호출 시간이 짧아지므로 성능이 향상된다.

- 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.
- 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출 하고자 하는 경우에는 인스턴스를 생성해야한다.


■ 오버로딩 
- 메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각기 다른 이름을 가져야한다.
- 같은 메서드 이름을 가지더라도 매개변수의 개수 or 타입이 다르면 메서드를 정의할 수 있다.
- 반환 타입은 오버로딩의 조건이 될 수 없다.


■ 생성자
- 생성자는 인스턴스가 생성될 때 호출되는 "인스턴스 초기화 메서드"이다.
- 인스턴스 생성시에 실행되어야 하는 작업을 위해 사용된다.

1. 생성자의 이름을 클래스의 이름과 같아야한다.
2. 생성자는 리턴 값이 없다.

ex)
클래스 이름(타입 변수명, 타입 변수명) {
 인스턴스 생성시 수행될 코드, 인스턴스 변수의 초기화 코드를 적는다.
}

!! 연산자 new 가 인스턴스를 생성하는 것이며, 생성자는 인스턴스를 초기화 시켜준다.

- 생성자가 하나도 없으면 기본 생성자를 프로그램에서 자동으로 만들어 준다.
- 그러나, 기본 생성자 없이, 매개변수를 가진 생성자를 만들고, 기본 생성자 호출시 에러 발생.


■ 생성자에서 다른 생성자 호출하기
- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.


■ this
- 인스턴스 자신을 ㅏ리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
- 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.


■ 변수의 초기화
- 멤버 변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어진다.
- 그러나 지역 변수는 사용하기 전에 반드시 초기화를 해야한다.

1. 클래스 변수 초기화 => 인스턴스 변수 초기화
2. 자동 초기화 => 명시적 초기화(간단) => 초기화 블럭, 생성자(복잡)
=> 명시적 초기화 : 변수를 선언과 동시에 초기화 하는 방법.
=> 초기화 블럭 : 클래스 초기화 블럭, 인스턴스 초기화 블럭 / 복잡한 초기화에 사용
