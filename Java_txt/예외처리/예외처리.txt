■ 에러
컴파일 에러 : 컴파일시 발생하는 에러.
런타임 에러 : 런타임시 발생하는 에러.
논리적 에러 : 실행은 되지만 의도와 다르게 동작하는 것.

■ 에러 vs 예외
에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류.
예외 : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류.

■ 예외처리
- 정의 : 프로그램 실행시 발생할 수 있는 예외에 대비한 코드를 작성하는 것.
- 목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행 상태를 유지하는 것.
- 발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되고, 처리되지 못한 예외는
JVM의 예외처리기가 받아서 예외의 원인을 화면에 출력한다.

■ try-catch문
try { 실행할 코드 }
catch(처리할 예외) { 예외가 발생하였을 때 실행할 코드}

- 하나의 try블럭 다음에는 에러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블록이 온다.
- 이 중 발생한 예외의 종류와 일치하는 단 한 개의 catch 블록만 수행된다.
- 발생한 예외의 종류와 일치하는 catch 블럭이 없으면 예외는 처리되지 않는다.
- try에서 발생한 예외에 해당하는 catch문이 실행되면, try-catch 문을 벗어난다.

■ printStackTrace()와 getMessage()
printStackTrace() : 예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메세지를 화면에 출력한다.
getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.

■ 예외 발생시키기
- 키워드 throw를 이용하여 프로그래머가 고의로 예외를 발생시킬 수 있다.
1. new 연산자를 이용하여 발생시키려는 예외 클래스의 객체를 만든 다음
2. 키워드 throw를 이용하여 예외를 발생시킨다.

Exception e = new Exception("고의로 예외 발생");
throw e;
=> throw new Exception("고의로 예외 발생");

■ checked 예외와 uncheck 예외

■ 메서드에 예외 선언하기
- try-catch문 대신 사용가능.
- 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에 발생할 수 있는 예외를 적어주면 된다.
- 예외가 여러개일 경우, 쉼표(,)로 구분한다.
void method() throws Exception1, Exception2, ... {}

-!! throw 키워드외 throws 키워드를 혼동하면 안된다.

- 조상타입의 예외클래스를 선언하면, 자손타입의 예외 발생 가능한 점에 주의.
- 오버라이딩할 때는 단순히 선언된 예외의 개수가 아니라 상속관계까지 고려해야한다.
- 메서드 선언부에 예외를 선언함으로써 메서드를 사용하려는 사림이 메서드의 선언부를 보았을 때
이 메서드를 사용하기 위해서는 어떠한 예외들이 처리되어져야 하는 지 쉽게 알 수 있다.

■ finally 블럭
- 예외 발생여부에 상관없이 실행되어얌만 하는 코드를 포함시킬 목적으로 사용된다.
- try-catch-finally

■ 사용자 정의 예외 만들기
- 필요에 따라 프로그래머가 새로운 예외 클래스를 정의하여 사용

■ 예외 되던지기
- 예외가 발생한 메서드와 호출한 메서드, 양쪽에서 처리하는 방식
- 예외처리 후 인위적인 방법을 통해서 가능
- catch문에서 throw를 통해 예외를 다시 발생시키는 것
- 메서드 선언부에 throws를 지정(발생할 예외를), try-catch도 지정해야함.

■ 연결된 예외
- 예외 A가 예외 B를 발생시켰다면, A를 B의 원인 예외라고 한다.
- 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위함이다.
- checked 예외를 unchecked 예외로 바꿀수 있도록 하기 위해서이다.
